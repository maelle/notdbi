[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 notdbi authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/spec.html","id":"dbi-r-database-interface","dir":"Articles","previous_headings":"","what":"DBI: R Database Interface","title":"DBI specification","text":"DBI defines interface communication R relational database management systems. classes package virtual need extended various R/DBMS implementations (-called DBI backends).","code":""},{"path":"/articles/spec.html","id":"definition","dir":"Articles","previous_headings":"DBI: R Database Interface","what":"Definition","title":"DBI specification","text":"DBI backend R package imports DBI methods packages. better worse, names many existing backends start ‘R’, e.g., RSQLite, RMySQL, RSQLServer; backend author adopt convention .","code":""},{"path":"/articles/spec.html","id":"dbi-classes-and-methods","dir":"Articles","previous_headings":"DBI: R Database Interface","what":"DBI classes and methods","title":"DBI specification","text":"backend defines three classes, subclasses DBIDriver, DBIConnection, DBIResult. backend provides implementation methods base classes defined implemented DBI. methods defined DBI reexported (package can used without attach DBI), ellipsis ... formals extensibility.","code":""},{"path":"/articles/spec.html","id":"construction-of-the-dbidriver-object","dir":"Articles","previous_headings":"DBI: R Database Interface","what":"Construction of the DBIDriver object","title":"DBI specification","text":"backend must support creation instance DBIDriver subclass constructor function. default, name package name without leading ‘R’ (exists), e.g., SQLite RSQLite package. However, backend authors may choose different name. constructor must exported, must function callable without arguments. DBI recommends define constructor empty argument list.","code":""},{"path":"/articles/spec.html","id":"examples","dir":"Articles","previous_headings":"DBI: R Database Interface","what":"Examples","title":"DBI specification","text":"","code":"RSQLite::SQLite()"},{"path":"/articles/spec.html","id":"determine-the-sql-data-type-of-an-object","dir":"Articles","previous_headings":"","what":"Determine the SQL data type of an object","title":"DBI specification","text":"section describes behavior following method:","code":"dbDataType(dbObj, obj, ...)"},{"path":"/articles/spec.html","id":"description","dir":"Articles","previous_headings":"Determine the SQL data type of an object","what":"Description","title":"DBI specification","text":"Returns SQL string describes SQL data type used object. default implementation generic determines SQL type R object according SQL 92 specification, may serve starting point driver implementations. DBI also provides implementation data.frame return character vector giving type column dataframe.","code":""},{"path":[]},{"path":"/articles/spec.html","id":"details","dir":"Articles","previous_headings":"Determine the SQL data type of an object","what":"Details","title":"DBI specification","text":"data types supported databases different data types R, mapping primitive types straightforward: many fixed varying length character types mapped character vectors Fixed-precision (non-IEEE) numbers mapped either numeric integer vectors. Notice many DBMS follow IEEE arithmetic, potential problems /overflows loss precision.","code":""},{"path":"/articles/spec.html","id":"value","dir":"Articles","previous_headings":"Determine the SQL data type of an object","what":"Value","title":"DBI specification","text":"dbDataType() returns SQL type corresponds obj argument non-empty character string. data frames, character vector one element per column returned.","code":""},{"path":"/articles/spec.html","id":"failure-modes","dir":"Articles","previous_headings":"Determine the SQL data type of an object","what":"Failure modes","title":"DBI specification","text":"error raised invalid values obj argument NULL value.","code":""},{"path":"/articles/spec.html","id":"specification","dir":"Articles","previous_headings":"Determine the SQL data type of an object","what":"Specification","title":"DBI specification","text":"backend can override dbDataType() generic driver class. generic expects arbitrary object second argument. query values returned default implementation, run example(dbDataType, package = \"DBI\"). backend needs override generic, must accept basic R data types second argument, namely logical, integer, numeric, character, dates (see Dates), date-time (see DateTimeClasses), difftime. database supports blobs, method also must accept lists raw vectors, blob::blob objects. -objects (.e., wrapped ()) must supported return results unwrapped counterparts. SQL data type factor ordered character. behavior object types specified. data types returned dbDataType() usable SQL statement form \"CREATE TABLE test (...)\".","code":""},{"path":"/articles/spec.html","id":"examples-1","dir":"Articles","previous_headings":"Determine the SQL data type of an object","what":"Examples","title":"DBI specification","text":"","code":"dbDataType(ANSI(), 1:5) dbDataType(ANSI(), 1) dbDataType(ANSI(), TRUE) dbDataType(ANSI(), Sys.Date()) dbDataType(ANSI(), Sys.time()) dbDataType(ANSI(), Sys.time() - as.POSIXct(Sys.Date())) dbDataType(ANSI(), c(\"x\", \"abc\")) dbDataType(ANSI(), list(raw(10), raw(20))) dbDataType(ANSI(), I(3))  dbDataType(ANSI(), iris)   con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbDataType(con, 1:5) dbDataType(con, 1) dbDataType(con, TRUE) dbDataType(con, Sys.Date()) dbDataType(con, Sys.time()) dbDataType(con, Sys.time() - as.POSIXct(Sys.Date())) dbDataType(con, c(\"x\", \"abc\")) dbDataType(con, list(raw(10), raw(20))) dbDataType(con, I(3))  dbDataType(con, iris)  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"create-a-connection-to-a-dbms","dir":"Articles","previous_headings":"","what":"Create a connection to a DBMS","title":"DBI specification","text":"section describes behavior following method:","code":"dbConnect(drv, ...)"},{"path":"/articles/spec.html","id":"description-1","dir":"Articles","previous_headings":"Create a connection to a DBMS","what":"Description","title":"DBI specification","text":"Connect DBMS going appropriate authentication procedure. implementations may allow multiple connections open, may invoke function repeatedly assigning output different objects. authentication mechanism left unspecified, check documentation individual drivers details. Use dbCanConnect() check connection can established.","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-1","dir":"Articles","previous_headings":"Create a connection to a DBMS","what":"Value","title":"DBI specification","text":"dbConnect() returns S4 object inherits DBIConnection. object used communicate database engine. format() method defined connection object. returns string consists single line text.","code":""},{"path":"/articles/spec.html","id":"specification-1","dir":"Articles","previous_headings":"Create a connection to a DBMS","what":"Specification","title":"DBI specification","text":"DBI recommends using following argument names authentication parameters, NULL default: user user name (default: current user) password password host host name (default: local connection) port port number (default: local connection) dbname name database host, database file name defaults provide reasonable behavior, particular local connection host = NULL. DBMS (e.g., PostgreSQL), different TCP/IP connection localhost. addition, DBI supports bigint argument governs 64-bit integer data returned. following values supported: \"integer\": always return integer, silently overflow \"numeric\": always return numeric, silently round \"character\": always return decimal representation character \"integer64\": return data type can coerced using .integer() (warning overflow), .numeric() .character()","code":""},{"path":"/articles/spec.html","id":"examples-2","dir":"Articles","previous_headings":"Create a connection to a DBMS","what":"Examples","title":"DBI specification","text":"","code":"# SQLite only needs a path to the database. (Here, \":memory:\" is a special # path that creates an in-memory database.) Other database drivers # will require more details (like user, password, host, port, etc.) con <- dbConnect(RSQLite::SQLite(), \":memory:\") con  dbListTables(con)  dbDisconnect(con)  # Bad, for subtle reasons: # This code fails when RSQLite isn't loaded yet, # because dbConnect() doesn't know yet about RSQLite. dbListTables(con <- dbConnect(RSQLite::SQLite(), \":memory:\"))"},{"path":"/articles/spec.html","id":"disconnect-close-a-connection","dir":"Articles","previous_headings":"","what":"Disconnect (close) a connection","title":"DBI specification","text":"section describes behavior following method:","code":"dbDisconnect(conn, ...)"},{"path":"/articles/spec.html","id":"description-2","dir":"Articles","previous_headings":"Disconnect (close) a connection","what":"Description","title":"DBI specification","text":"closes connection, discards pending work, frees resources (e.g., memory, sockets).","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-2","dir":"Articles","previous_headings":"Disconnect (close) a connection","what":"Value","title":"DBI specification","text":"dbDisconnect() returns TRUE, invisibly.","code":""},{"path":"/articles/spec.html","id":"failure-modes-1","dir":"Articles","previous_headings":"Disconnect (close) a connection","what":"Failure modes","title":"DBI specification","text":"warning issued garbage collection connection released without calling dbDisconnect(), tested automatically. least one warning issued immediately calling dbDisconnect() already disconnected invalid connection.","code":""},{"path":"/articles/spec.html","id":"examples-3","dir":"Articles","previous_headings":"Disconnect (close) a connection","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\") dbDisconnect(con)"},{"path":"/articles/spec.html","id":"execute-a-query-on-a-given-database-connection","dir":"Articles","previous_headings":"","what":"Execute a query on a given database connection","title":"DBI specification","text":"section describes behavior following method:","code":"dbSendQuery(conn, statement, ...)"},{"path":"/articles/spec.html","id":"description-3","dir":"Articles","previous_headings":"Execute a query on a given database connection","what":"Description","title":"DBI specification","text":"dbSendQuery() method submits synchronously executes SQL query database engine. extract records — need use dbFetch() method, must call dbClearResult() finish fetching records need. interactive use, almost always prefer dbGetQuery(). Use dbSendQueryArrow() dbGetQueryArrow() instead retrieve results Arrow object.","code":""},{"path":[]},{"path":"/articles/spec.html","id":"additional-arguments","dir":"Articles","previous_headings":"Execute a query on a given database connection","what":"Additional arguments","title":"DBI specification","text":"following arguments part dbSendQuery() generic (improve compatibility across backends) part DBI specification: params (default: NULL) immediate (default: NULL) must provided named arguments. See “Specification” sections details usage.","code":""},{"path":"/articles/spec.html","id":"specification-2","dir":"Articles","previous_headings":"Execute a query on a given database connection","what":"Specification","title":"DBI specification","text":"warnings occur normal conditions. done, DBIResult object must cleared call dbClearResult(). Failure clear result set leads warning connection closed. backend supports one open result set per connection, issuing second query invalidates already open result set raises warning. newly opened result set valid must cleared dbClearResult(). param argument allows passing query parameters, see dbBind() details.","code":""},{"path":"/articles/spec.html","id":"specification-for-the-immediate-argument","dir":"Articles","previous_headings":"Execute a query on a given database connection","what":"Specification for the immediate argument","title":"DBI specification","text":"immediate argument supports distinguishing “direct” “prepared” APIs offered many database drivers. Passing immediate = TRUE leads immediate execution query statement, via “direct” API (supported driver). default NULL means backend choose whatever API makes sense database, (relevant) tries API first attempt fails. successful second attempt result message suggests passing correct immediate argument. Examples possible behaviors: DBI backend defaults immediate = TRUE internally query without parameters passed: query executed query parameters passed: params given: rejected immediately database syntax error query, backend tries immediate = FALSE (gives message) params given: query executed using immediate = FALSE DBI backend defaults immediate = FALSE internally query without parameters passed: simple query: query executed “special” query (setting config options): fails, backend tries immediate = TRUE (gives message) query parameters passed: params given: waiting parameters via dbBind() params given: query executed","code":""},{"path":"/articles/spec.html","id":"details-1","dir":"Articles","previous_headings":"Execute a query on a given database connection","what":"Details","title":"DBI specification","text":"method SELECT queries . backends may support data manipulation queries method compatibility reasons. However, callers strongly encouraged use dbSendStatement() data manipulation statements. query submitted database server DBMS executes , possibly generating vast amounts data. data live driver-specific: drivers may choose leave output server transfer piecemeal R, others may transfer data client – necessarily memory R manages. See individual drivers’ dbSendQuery() documentation details.","code":""},{"path":"/articles/spec.html","id":"value-3","dir":"Articles","previous_headings":"Execute a query on a given database connection","what":"Value","title":"DBI specification","text":"dbSendQuery() returns S4 object inherits DBIResult. result set can used dbFetch() extract records. finished using result, make sure clear dbClearResult().","code":""},{"path":"/articles/spec.html","id":"the-data-retrieval-flow","dir":"Articles","previous_headings":"Execute a query on a given database connection","what":"The data retrieval flow","title":"DBI specification","text":"section gives complete overview flow execution queries return tabular data data frames. flow, except repeated calling dbBind() dbBindArrow(), implemented dbGetQuery(), sufficient unless want access results paged way parameterized query want reuse. flow requires active connection established dbConnect(). See also vignette(\"dbi-advanced\") walkthrough. Use dbSendQuery() create result set object class DBIResult. Optionally, bind query parameters dbBind() dbBindArrow(). required query contains placeholders ⁠?⁠ ⁠\\$1⁠, depending database backend. Optionally, use dbColumnInfo() retrieve structure result set without retrieving actual data. Use dbFetch() get entire result set, page results, remaining rows. Fetching zero rows also possible retrieve structure result set data frame. step can called multiple times. forward paging supported, need cache previous pages need navigate backwards. Use dbHasCompleted() tell ’re done. method returns TRUE rows available fetching. Repeat last four steps necessary. Use dbClearResult() clean result set object. step mandatory even rows fetched error occurred processing. good practice use .exit() withr::defer() ensure step always executed.","code":""},{"path":"/articles/spec.html","id":"failure-modes-2","dir":"Articles","previous_headings":"Execute a query on a given database connection","what":"Failure modes","title":"DBI specification","text":"error raised issuing query closed invalid connection, query non-NA string. error also raised syntax query invalid query parameters given (passing params argument) immediate argument set TRUE.","code":""},{"path":"/articles/spec.html","id":"examples-4","dir":"Articles","previous_headings":"Execute a query on a given database connection","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"mtcars\", mtcars) rs <- dbSendQuery(con, \"SELECT * FROM mtcars WHERE cyl = 4\") dbFetch(rs) dbClearResult(rs)  # Pass one set of values with the param argument: rs <- dbSendQuery(   con,   \"SELECT * FROM mtcars WHERE cyl = ?\",   params = list(4L) ) dbFetch(rs) dbClearResult(rs)  # Pass multiple sets of values with dbBind(): rs <- dbSendQuery(con, \"SELECT * FROM mtcars WHERE cyl = ?\") dbBind(rs, list(6L)) dbFetch(rs) dbBind(rs, list(8L)) dbFetch(rs) dbClearResult(rs)  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"fetch-records-from-a-previously-executed-query","dir":"Articles","previous_headings":"","what":"Fetch records from a previously executed query","title":"DBI specification","text":"section describes behavior following methods:","code":"dbFetch(res, n = -1, ...)  fetch(res, n = -1, ...)"},{"path":"/articles/spec.html","id":"description-4","dir":"Articles","previous_headings":"Fetch records from a previously executed query","what":"Description","title":"DBI specification","text":"Fetch next n elements (rows) result set return data.frame.","code":""},{"path":[]},{"path":"/articles/spec.html","id":"details-2","dir":"Articles","previous_headings":"Fetch records from a previously executed query","what":"Details","title":"DBI specification","text":"fetch() provided compatibility older DBI clients - new code strongly encouraged use dbFetch(). default implementation dbFetch() calls fetch() compatible existing code. Modern backends implement dbFetch() .","code":""},{"path":"/articles/spec.html","id":"value-4","dir":"Articles","previous_headings":"Fetch records from a previously executed query","what":"Value","title":"DBI specification","text":"dbFetch() always returns data.frame many rows records fetched many columns fields result set, even result single value one zero rows. Passing n = NA supported returns arbitrary number rows (least one) specified driver, remaining rows result set.","code":""},{"path":"/articles/spec.html","id":"the-data-retrieval-flow-1","dir":"Articles","previous_headings":"Fetch records from a previously executed query","what":"The data retrieval flow","title":"DBI specification","text":"section gives complete overview flow execution queries return tabular data data frames. flow, except repeated calling dbBind() dbBindArrow(), implemented dbGetQuery(), sufficient unless want access results paged way parameterized query want reuse. flow requires active connection established dbConnect(). See also vignette(\"dbi-advanced\") walkthrough. Use dbSendQuery() create result set object class DBIResult. Optionally, bind query parameters dbBind() dbBindArrow(). required query contains placeholders ⁠?⁠ ⁠\\$1⁠, depending database backend. Optionally, use dbColumnInfo() retrieve structure result set without retrieving actual data. Use dbFetch() get entire result set, page results, remaining rows. Fetching zero rows also possible retrieve structure result set data frame. step can called multiple times. forward paging supported, need cache previous pages need navigate backwards. Use dbHasCompleted() tell ’re done. method returns TRUE rows available fetching. Repeat last four steps necessary. Use dbClearResult() clean result set object. step mandatory even rows fetched error occurred processing. good practice use .exit() withr::defer() ensure step always executed.","code":""},{"path":"/articles/spec.html","id":"failure-modes-3","dir":"Articles","previous_headings":"Fetch records from a previously executed query","what":"Failure modes","title":"DBI specification","text":"attempt fetch closed result set raises error. n argument atomic whole number greater equal -1 Inf, error raised, subsequent call dbFetch() proper n argument succeeds. Calling dbFetch() result set data manipulation query created dbSendStatement() can fetched return empty data frame, warning.","code":""},{"path":"/articles/spec.html","id":"specification-3","dir":"Articles","previous_headings":"Fetch records from a previously executed query","what":"Specification","title":"DBI specification","text":"Fetching multi-row queries one columns default returns entire result. Multi-row queries can also fetched progressively passing whole number (integer numeric) n argument. value Inf n argument supported also returns full result. rows available fetched, result returned full without warning. fewer rows requested returned, fetches return data frame zero rows. zero rows fetched, columns data frame still fully typed. Fetching fewer rows available permitted, warning issued clearing result set. column named row_names treated like column. column types returned data frame depend data returned: integer (coercible integer) integer values -2^31 2^31 - 1, NA SQL NULL values numeric numbers fractional component, NA SQL NULL values logical Boolean values (backends may return integer); NA SQL NULL values character text, NA SQL NULL values lists raw blobs NULL entries SQL NULL values coercible using .Date() dates, NA SQL NULL values (also applies return value SQL function current_date) coercible using hms::as_hms() times, NA SQL NULL values (also applies return value SQL function current_time) coercible using .POSIXct() timestamps, NA SQL NULL values (also applies return value SQL function current_timestamp) dates timestamps supported backend, following R types used: Date dates (also applies return value SQL function current_date) POSIXct timestamps (also applies return value SQL function current_timestamp) R built-type lossless support full range 64-bit larger integers. 64-bit integers returned query, following rules apply: Values returned container support full range valid 64-bit values (integer64 class bit64 package) Coercion numeric always returns number close possible true value Loss precision converting numeric gives warning Conversion character always returns lossless decimal representation data","code":""},{"path":"/articles/spec.html","id":"examples-5","dir":"Articles","previous_headings":"Fetch records from a previously executed query","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"mtcars\", mtcars)  # Fetch all results rs <- dbSendQuery(con, \"SELECT * FROM mtcars WHERE cyl = 4\") dbFetch(rs) dbClearResult(rs)  # Fetch in chunks rs <- dbSendQuery(con, \"SELECT * FROM mtcars\") while (!dbHasCompleted(rs)) {   chunk <- dbFetch(rs, 10)   print(nrow(chunk)) }  dbClearResult(rs) dbDisconnect(con)"},{"path":"/articles/spec.html","id":"clear-a-result-set","dir":"Articles","previous_headings":"","what":"Clear a result set","title":"DBI specification","text":"section describes behavior following method:","code":"dbClearResult(res, ...)"},{"path":"/articles/spec.html","id":"description-5","dir":"Articles","previous_headings":"Clear a result set","what":"Description","title":"DBI specification","text":"Frees resources (local remote) associated result set. step mandatory objects obtained calling dbSendQuery() dbSendStatement().","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-5","dir":"Articles","previous_headings":"Clear a result set","what":"Value","title":"DBI specification","text":"dbClearResult() returns TRUE, invisibly, result sets obtained dbSendQuery(), dbSendStatement(), dbSendQueryArrow(),","code":""},{"path":"/articles/spec.html","id":"the-data-retrieval-flow-2","dir":"Articles","previous_headings":"Clear a result set","what":"The data retrieval flow","title":"DBI specification","text":"section gives complete overview flow execution queries return tabular data data frames. flow, except repeated calling dbBind() dbBindArrow(), implemented dbGetQuery(), sufficient unless want access results paged way parameterized query want reuse. flow requires active connection established dbConnect(). See also vignette(\"dbi-advanced\") walkthrough. Use dbSendQuery() create result set object class DBIResult. Optionally, bind query parameters dbBind() dbBindArrow(). required query contains placeholders ⁠?⁠ ⁠\\$1⁠, depending database backend. Optionally, use dbColumnInfo() retrieve structure result set without retrieving actual data. Use dbFetch() get entire result set, page results, remaining rows. Fetching zero rows also possible retrieve structure result set data frame. step can called multiple times. forward paging supported, need cache previous pages need navigate backwards. Use dbHasCompleted() tell ’re done. method returns TRUE rows available fetching. Repeat last four steps necessary. Use dbClearResult() clean result set object. step mandatory even rows fetched error occurred processing. good practice use .exit() withr::defer() ensure step always executed.","code":""},{"path":"/articles/spec.html","id":"the-command-execution-flow","dir":"Articles","previous_headings":"Clear a result set","what":"The command execution flow","title":"DBI specification","text":"section gives complete overview flow execution SQL statements side effects stored procedures, inserting deleting data, setting database connection options. flow, except repeated calling dbBindArrow(), implemented dbExecute(), sufficient non-parameterized queries. flow requires active connection established dbConnect(). See also vignette(\"dbi-advanced\") walkthrough. Use dbSendStatement() create result set object class DBIResult. queries need pass immediate = TRUE. Optionally, bind query parameters withdbBind() dbBindArrow(). required query contains placeholders ⁠?⁠ ⁠\\$1⁠, depending database backend. Optionally, use dbGetRowsAffected() retrieve number rows affected query. Repeat last two steps necessary. Use dbClearResult() clean result set object. step mandatory even rows fetched error occurred processing. good practice use .exit() withr::defer() ensure step always executed.","code":""},{"path":"/articles/spec.html","id":"failure-modes-4","dir":"Articles","previous_headings":"Clear a result set","what":"Failure modes","title":"DBI specification","text":"attempt close already closed result set issues warning dbSendQuery(), dbSendStatement(), dbSendQueryArrow(),","code":""},{"path":"/articles/spec.html","id":"specification-4","dir":"Articles","previous_headings":"Clear a result set","what":"Specification","title":"DBI specification","text":"dbClearResult() frees resources associated retrieving result query update operation. DBI backend can expect call dbClearResult() dbSendQuery() dbSendStatement() call.","code":""},{"path":"/articles/spec.html","id":"examples-6","dir":"Articles","previous_headings":"Clear a result set","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  rs <- dbSendQuery(con, \"SELECT 1\") print(dbFetch(rs))  dbClearResult(rs) dbDisconnect(con)"},{"path":"/articles/spec.html","id":"bind-values-to-a-parameterizedprepared-statement","dir":"Articles","previous_headings":"","what":"Bind values to a parameterized/prepared statement","title":"DBI specification","text":"section describes behavior following methods:","code":"dbBind(res, params, ...)  dbBindArrow(res, params, ...)"},{"path":"/articles/spec.html","id":"description-6","dir":"Articles","previous_headings":"Bind values to a parameterized/prepared statement","what":"Description","title":"DBI specification","text":"parametrized prepared statements, dbSendQuery(), dbSendQueryArrow(), dbSendStatement() functions can called statements contain placeholders values. dbBind() dbBindArrow() functions bind placeholders actual values, intended called result set calling dbFetch() dbFetchArrow(). values passed dbBind() lists data frames, dbBindArrow() stream created nanoarrow::as_nanoarrow_array_stream().  dbBindArrow() experimental, ⁠*Arrow⁠ functions. dbSendQuery() compatible dbBindArrow(), dbSendQueryArrow() compatible dbBind().","code":""},{"path":[]},{"path":"/articles/spec.html","id":"details-3","dir":"Articles","previous_headings":"Bind values to a parameterized/prepared statement","what":"Details","title":"DBI specification","text":"DBI supports parametrized (prepared) queries statements via dbBind() dbBindArrow() generics. Parametrized queries different normal queries allow arbitrary number placeholders, later substituted actual values. Parametrized queries (statements) serve two purposes: query can executed different values. DBMS may cache intermediate information query, execution plan, execute faster. Separation query syntax parameters protects SQL injection. placeholder format currently specified DBI; future, uniform placeholder syntax may supported. Consult backend documentation supported formats. automated testing, backend authors specify placeholder syntax placeholder_pattern tweak. Known examples : ⁠?⁠ (positional matching order appearance) RMariaDB RSQLite ⁠\\$1⁠ (positional matching index) RPostgres RSQLite ⁠:name⁠ ⁠\\$name⁠ (named matching) RSQLite","code":""},{"path":"/articles/spec.html","id":"value-6","dir":"Articles","previous_headings":"Bind values to a parameterized/prepared statement","what":"Value","title":"DBI specification","text":"dbBind() returns result set, invisibly, queries issued dbSendQuery() dbSendQueryArrow() also data manipulation statements issued dbSendStatement().","code":""},{"path":"/articles/spec.html","id":"the-data-retrieval-flow-3","dir":"Articles","previous_headings":"Bind values to a parameterized/prepared statement","what":"The data retrieval flow","title":"DBI specification","text":"section gives complete overview flow execution queries return tabular data data frames. flow, except repeated calling dbBind() dbBindArrow(), implemented dbGetQuery(), sufficient unless want access results paged way parameterized query want reuse. flow requires active connection established dbConnect(). See also vignette(\"dbi-advanced\") walkthrough. Use dbSendQuery() create result set object class DBIResult. Optionally, bind query parameters dbBind() dbBindArrow(). required query contains placeholders ⁠?⁠ ⁠\\$1⁠, depending database backend. Optionally, use dbColumnInfo() retrieve structure result set without retrieving actual data. Use dbFetch() get entire result set, page results, remaining rows. Fetching zero rows also possible retrieve structure result set data frame. step can called multiple times. forward paging supported, need cache previous pages need navigate backwards. Use dbHasCompleted() tell ’re done. method returns TRUE rows available fetching. Repeat last four steps necessary. Use dbClearResult() clean result set object. step mandatory even rows fetched error occurred processing. good practice use .exit() withr::defer() ensure step always executed.","code":""},{"path":"/articles/spec.html","id":"the-data-retrieval-flow-for-arrow-streams","dir":"Articles","previous_headings":"Bind values to a parameterized/prepared statement","what":"The data retrieval flow for Arrow streams","title":"DBI specification","text":"section gives complete overview flow execution queries return tabular data Arrow stream. flow, except repeated calling dbBindArrow() dbBind(), implemented dbGetQueryArrow(), sufficient unless parameterized query want reuse. flow requires active connection established dbConnect(). See also vignette(\"dbi-advanced\") walkthrough. Use dbSendQueryArrow() create result set object class DBIResultArrow. Optionally, bind query parameters dbBindArrow() dbBind(). required query contains placeholders ⁠?⁠ ⁠\\$1⁠, depending database backend. Use dbFetchArrow() get data stream. Repeat last two steps necessary. Use dbClearResult() clean result set object. step mandatory even rows fetched error occurred processing. good practice use .exit() withr::defer() ensure step always executed.","code":""},{"path":"/articles/spec.html","id":"the-command-execution-flow-1","dir":"Articles","previous_headings":"Bind values to a parameterized/prepared statement","what":"The command execution flow","title":"DBI specification","text":"section gives complete overview flow execution SQL statements side effects stored procedures, inserting deleting data, setting database connection options. flow, except repeated calling dbBindArrow(), implemented dbExecute(), sufficient non-parameterized queries. flow requires active connection established dbConnect(). See also vignette(\"dbi-advanced\") walkthrough. Use dbSendStatement() create result set object class DBIResult. queries need pass immediate = TRUE. Optionally, bind query parameters withdbBind() dbBindArrow(). required query contains placeholders ⁠?⁠ ⁠\\$1⁠, depending database backend. Optionally, use dbGetRowsAffected() retrieve number rows affected query. Repeat last two steps necessary. Use dbClearResult() clean result set object. step mandatory even rows fetched error occurred processing. good practice use .exit() withr::defer() ensure step always executed.","code":""},{"path":"/articles/spec.html","id":"failure-modes-5","dir":"Articles","previous_headings":"Bind values to a parameterized/prepared statement","what":"Failure modes","title":"DBI specification","text":"Calling dbBind() query without parameters raises error. Binding many enough values, parameters wrong names unequal length, also raises error. placeholders query named, parameter values must names (must empty NA), vice versa, otherwise error raised. behavior mixing placeholders different types (particular mixing positional named placeholders) specified. Calling dbBind() result set already cleared dbClearResult() also raises error.","code":""},{"path":"/articles/spec.html","id":"specification-5","dir":"Articles","previous_headings":"Bind values to a parameterized/prepared statement","what":"Specification","title":"DBI specification","text":"DBI clients execute parametrized statements follows: Call dbSendQuery(), dbSendQueryArrow() dbSendStatement() query statement contains placeholders, store returned DBIResult object variable. Mixing placeholders (particular, named unnamed ones) recommended. good practice register call dbClearResult() via .exit() right calling dbSendQuery() dbSendStatement() (see last enumeration item). dbBind() dbBindArrow() called, returned result set object following behavior: dbFetch() raises error (dbSendQuery() dbSendQueryArrow()) dbGetRowCount() returns zero (dbSendQuery() dbSendQueryArrow()) dbGetRowsAffected() returns integer NA (dbSendStatement()) dbIsValid() returns TRUE dbHasCompleted() returns FALSE Call dbBind() dbBindArrow(): dbBind(), params argument must list elements lengths contain values supported backend. data.frame internally stored list. dbBindArrow(), params argument must nanoarrow array stream, one column per query parameter. Retrieve data number affected rows DBIResult object. queries issued dbSendQuery() dbSendQueryArrow(), call dbFetch(). statements issued dbSendStatements(), call dbGetRowsAffected(). (Execution begins immediately dbBind() call, statement processed entirely function returns.) Repeat 2. 3. necessary. Close result set via dbClearResult(). elements params argument need scalars, vectors arbitrary length (including length 0) supported. queries, calling dbFetch() binding parameters returns concatenated results, equivalent binding fetching set values connecting via rbind(). data manipulation statements, dbGetRowsAffected() returns total number rows affected binding non-scalar parameters. dbBind() also accepts repeated calls result set queries data manipulation statements, even results fetched calls dbBind(), queries data manipulation statements. placeholders query named, order params argument important. least following data types accepted input (including NA): integer numeric logical Boolean values character (also special characters spaces, newlines, quotes, backslashes) factor (bound character, warning) Date (also stored internally integer) POSIXct timestamps POSIXlt timestamps difftime values (also units seconds value stored integer) lists raw blobs (NULL entries SQL NULL values) objects type blob::blob","code":""},{"path":"/articles/spec.html","id":"examples-7","dir":"Articles","previous_headings":"Bind values to a parameterized/prepared statement","what":"Examples","title":"DBI specification","text":"","code":"# Data frame flow: con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"iris\", iris)  # Using the same query for different values iris_result <- dbSendQuery(con, \"SELECT * FROM iris WHERE [Petal.Width] > ?\") dbBind(iris_result, list(2.3)) dbFetch(iris_result) dbBind(iris_result, list(3)) dbFetch(iris_result) dbClearResult(iris_result)  # Executing the same statement with different values at once iris_result <- dbSendStatement(con, \"DELETE FROM iris WHERE [Species] = \\$species\") dbBind(iris_result, list(species = c(\"setosa\", \"versicolor\", \"unknown\"))) dbGetRowsAffected(iris_result) dbClearResult(iris_result)  nrow(dbReadTable(con, \"iris\"))  dbDisconnect(con)    # Arrow flow: con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"iris\", iris)  # Using the same query for different values iris_result <- dbSendQueryArrow(con, \"SELECT * FROM iris WHERE [Petal.Width] > ?\") dbBindArrow(   iris_result,   nanoarrow::as_nanoarrow_array_stream(data.frame(2.3, fix.empty.names = FALSE)) ) as.data.frame(dbFetchArrow(iris_result)) dbBindArrow(   iris_result,   nanoarrow::as_nanoarrow_array_stream(data.frame(3, fix.empty.names = FALSE)) ) as.data.frame(dbFetchArrow(iris_result)) dbClearResult(iris_result)  # Executing the same statement with different values at once iris_result <- dbSendStatement(con, \"DELETE FROM iris WHERE [Species] = \\$species\") dbBindArrow(iris_result, nanoarrow::as_nanoarrow_array_stream(data.frame(   species = c(\"setosa\", \"versicolor\", \"unknown\") ))) dbGetRowsAffected(iris_result) dbClearResult(iris_result)  nrow(dbReadTable(con, \"iris\"))  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"retrieve-results-from-a-query","dir":"Articles","previous_headings":"","what":"Retrieve results from a query","title":"DBI specification","text":"section describes behavior following method:","code":"dbGetQuery(conn, statement, ...)"},{"path":"/articles/spec.html","id":"description-7","dir":"Articles","previous_headings":"Retrieve results from a query","what":"Description","title":"DBI specification","text":"Returns result query data frame. dbGetQuery() comes default implementation (work backends) calls dbSendQuery(), dbFetch(), ensuring result always freed dbClearResult(). retrieving chunked/paged results passing query parameters, see dbSendQuery(), particular “data retrieval flow” section. retrieving results Arrow object, see dbGetQueryArrow().","code":""},{"path":[]},{"path":"/articles/spec.html","id":"additional-arguments-1","dir":"Articles","previous_headings":"Retrieve results from a query","what":"Additional arguments","title":"DBI specification","text":"following arguments part dbGetQuery() generic (improve compatibility across backends) part DBI specification: n (default: -1) params (default: NULL) immediate (default: NULL) must provided named arguments. See “Specification” “Value” sections details usage.","code":""},{"path":"/articles/spec.html","id":"specification-6","dir":"Articles","previous_headings":"Retrieve results from a query","what":"Specification","title":"DBI specification","text":"column named row_names treated like column. n argument specifies number rows fetched. omitted, fetching multi-row queries one columns returns entire result. value Inf n argument supported also returns full result. rows available fetched (passing large value n), result returned full without warning. zero rows requested, columns data frame still fully typed. Fetching fewer rows available permitted, warning issued. param argument allows passing query parameters, see dbBind() details.","code":""},{"path":"/articles/spec.html","id":"specification-for-the-immediate-argument-1","dir":"Articles","previous_headings":"Retrieve results from a query","what":"Specification for the immediate argument","title":"DBI specification","text":"immediate argument supports distinguishing “direct” “prepared” APIs offered many database drivers. Passing immediate = TRUE leads immediate execution query statement, via “direct” API (supported driver). default NULL means backend choose whatever API makes sense database, (relevant) tries API first attempt fails. successful second attempt result message suggests passing correct immediate argument. Examples possible behaviors: DBI backend defaults immediate = TRUE internally query without parameters passed: query executed query parameters passed: params given: rejected immediately database syntax error query, backend tries immediate = FALSE (gives message) params given: query executed using immediate = FALSE DBI backend defaults immediate = FALSE internally query without parameters passed: simple query: query executed “special” query (setting config options): fails, backend tries immediate = TRUE (gives message) query parameters passed: params given: waiting parameters via dbBind() params given: query executed","code":""},{"path":"/articles/spec.html","id":"details-4","dir":"Articles","previous_headings":"Retrieve results from a query","what":"Details","title":"DBI specification","text":"method SELECT queries (incl. SQL statements return SELECT-alike result, e.g., execution stored procedure data manipulation queries like ⁠INSERT ... RETURNING ...⁠). execute stored procedure return result set, use dbExecute(). backends may support data manipulation statements method compatibility reasons. However, callers strongly advised use dbExecute() data manipulation statements.","code":""},{"path":"/articles/spec.html","id":"value-7","dir":"Articles","previous_headings":"Retrieve results from a query","what":"Value","title":"DBI specification","text":"dbGetQuery() always returns data.frame, many rows records fetched many columns fields result set, even result single value one zero rows.","code":""},{"path":"/articles/spec.html","id":"implementation-notes","dir":"Articles","previous_headings":"Retrieve results from a query","what":"Implementation notes","title":"DBI specification","text":"Subclasses override method provide sort performance optimization.","code":""},{"path":"/articles/spec.html","id":"failure-modes-6","dir":"Articles","previous_headings":"Retrieve results from a query","what":"Failure modes","title":"DBI specification","text":"error raised issuing query closed invalid connection, syntax query invalid, query non-NA string. n argument atomic whole number greater equal -1 Inf, error raised, subsequent call dbGetQuery() proper n argument succeeds.","code":""},{"path":"/articles/spec.html","id":"examples-8","dir":"Articles","previous_headings":"Retrieve results from a query","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"mtcars\", mtcars) dbGetQuery(con, \"SELECT * FROM mtcars\") dbGetQuery(con, \"SELECT * FROM mtcars\", n = 6)  # Pass values using the param argument: # (This query runs eight times, once for each different # parameter. The resulting rows are combined into a single # data frame.) dbGetQuery(   con,   \"SELECT COUNT(*) FROM mtcars WHERE cyl = ?\",   params = list(1:8) )  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"execute-a-data-manipulation-statement-on-a-given-database-connection","dir":"Articles","previous_headings":"","what":"Execute a data manipulation statement on a given database connection","title":"DBI specification","text":"section describes behavior following method:","code":"dbSendStatement(conn, statement, ...)"},{"path":"/articles/spec.html","id":"description-8","dir":"Articles","previous_headings":"Execute a data manipulation statement on a given database connection","what":"Description","title":"DBI specification","text":"dbSendStatement() method submits synchronously executes SQL data manipulation statement (e.g., UPDATE, DELETE, ⁠INSERT ⁠, ⁠DROP TABLE⁠, …) database engine. query number affected rows, call dbGetRowsAffected() returned result object. must also call dbClearResult() . interactive use, almost always prefer dbExecute().","code":""},{"path":[]},{"path":"/articles/spec.html","id":"additional-arguments-2","dir":"Articles","previous_headings":"Execute a data manipulation statement on a given database connection","what":"Additional arguments","title":"DBI specification","text":"following arguments part dbSendStatement() generic (improve compatibility across backends) part DBI specification: params (default: NULL) immediate (default: NULL) must provided named arguments. See “Specification” sections details usage.","code":""},{"path":"/articles/spec.html","id":"specification-7","dir":"Articles","previous_headings":"Execute a data manipulation statement on a given database connection","what":"Specification","title":"DBI specification","text":"warnings occur normal conditions. done, DBIResult object must cleared call dbClearResult(). Failure clear result set leads warning connection closed. backend supports one open result set per connection, issuing second query invalidates already open result set raises warning. newly opened result set valid must cleared dbClearResult(). param argument allows passing query parameters, see dbBind() details.","code":""},{"path":"/articles/spec.html","id":"specification-for-the-immediate-argument-2","dir":"Articles","previous_headings":"Execute a data manipulation statement on a given database connection","what":"Specification for the immediate argument","title":"DBI specification","text":"immediate argument supports distinguishing “direct” “prepared” APIs offered many database drivers. Passing immediate = TRUE leads immediate execution query statement, via “direct” API (supported driver). default NULL means backend choose whatever API makes sense database, (relevant) tries API first attempt fails. successful second attempt result message suggests passing correct immediate argument. Examples possible behaviors: DBI backend defaults immediate = TRUE internally query without parameters passed: query executed query parameters passed: params given: rejected immediately database syntax error query, backend tries immediate = FALSE (gives message) params given: query executed using immediate = FALSE DBI backend defaults immediate = FALSE internally query without parameters passed: simple query: query executed “special” query (setting config options): fails, backend tries immediate = TRUE (gives message) query parameters passed: params given: waiting parameters via dbBind() params given: query executed","code":""},{"path":"/articles/spec.html","id":"details-5","dir":"Articles","previous_headings":"Execute a data manipulation statement on a given database connection","what":"Details","title":"DBI specification","text":"dbSendStatement() comes default implementation simply forwards dbSendQuery(), support backends implement latter.","code":""},{"path":"/articles/spec.html","id":"value-8","dir":"Articles","previous_headings":"Execute a data manipulation statement on a given database connection","what":"Value","title":"DBI specification","text":"dbSendStatement() returns S4 object inherits DBIResult. result set can used dbGetRowsAffected() determine number rows affected query. finished using result, make sure clear dbClearResult().","code":""},{"path":"/articles/spec.html","id":"the-command-execution-flow-2","dir":"Articles","previous_headings":"Execute a data manipulation statement on a given database connection","what":"The command execution flow","title":"DBI specification","text":"section gives complete overview flow execution SQL statements side effects stored procedures, inserting deleting data, setting database connection options. flow, except repeated calling dbBindArrow(), implemented dbExecute(), sufficient non-parameterized queries. flow requires active connection established dbConnect(). See also vignette(\"dbi-advanced\") walkthrough. Use dbSendStatement() create result set object class DBIResult. queries need pass immediate = TRUE. Optionally, bind query parameters withdbBind() dbBindArrow(). required query contains placeholders ⁠?⁠ ⁠\\$1⁠, depending database backend. Optionally, use dbGetRowsAffected() retrieve number rows affected query. Repeat last two steps necessary. Use dbClearResult() clean result set object. step mandatory even rows fetched error occurred processing. good practice use .exit() withr::defer() ensure step always executed.","code":""},{"path":"/articles/spec.html","id":"failure-modes-7","dir":"Articles","previous_headings":"Execute a data manipulation statement on a given database connection","what":"Failure modes","title":"DBI specification","text":"error raised issuing statement closed invalid connection, statement non-NA string. error also raised syntax query invalid query parameters given (passing params argument) immediate argument set TRUE.","code":""},{"path":"/articles/spec.html","id":"examples-9","dir":"Articles","previous_headings":"Execute a data manipulation statement on a given database connection","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"cars\", head(cars, 3))  rs <- dbSendStatement(   con,   \"INSERT INTO cars (speed, dist) VALUES (1, 1), (2, 2), (3, 3)\" ) dbHasCompleted(rs) dbGetRowsAffected(rs) dbClearResult(rs) dbReadTable(con, \"cars\")   # there are now 6 rows  # Pass one set of values directly using the param argument: rs <- dbSendStatement(   con,   \"INSERT INTO cars (speed, dist) VALUES (?, ?)\",   params = list(4L, 5L) ) dbClearResult(rs)  # Pass multiple sets of values using dbBind(): rs <- dbSendStatement(   con,   \"INSERT INTO cars (speed, dist) VALUES (?, ?)\" ) dbBind(rs, list(5:6, 6:7)) dbBind(rs, list(7L, 8L)) dbClearResult(rs) dbReadTable(con, \"cars\")   # there are now 10 rows  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"change-database-state","dir":"Articles","previous_headings":"","what":"Change database state","title":"DBI specification","text":"section describes behavior following method:","code":"dbExecute(conn, statement, ...)"},{"path":"/articles/spec.html","id":"description-9","dir":"Articles","previous_headings":"Change database state","what":"Description","title":"DBI specification","text":"Executes statement returns number rows affected. dbExecute() comes default implementation (work backends) calls dbSendStatement(), dbGetRowsAffected(), ensuring result always freed dbClearResult(). passing query parameters, see dbBind(), particular “command execution flow” section.","code":""},{"path":[]},{"path":"/articles/spec.html","id":"additional-arguments-3","dir":"Articles","previous_headings":"Change database state","what":"Additional arguments","title":"DBI specification","text":"following arguments part dbExecute() generic (improve compatibility across backends) part DBI specification: params (default: NULL) immediate (default: NULL) must provided named arguments. See “Specification” sections details usage.","code":""},{"path":"/articles/spec.html","id":"specification-8","dir":"Articles","previous_headings":"Change database state","what":"Specification","title":"DBI specification","text":"param argument allows passing query parameters, see dbBind() details.","code":""},{"path":"/articles/spec.html","id":"specification-for-the-immediate-argument-3","dir":"Articles","previous_headings":"Change database state","what":"Specification for the immediate argument","title":"DBI specification","text":"immediate argument supports distinguishing “direct” “prepared” APIs offered many database drivers. Passing immediate = TRUE leads immediate execution query statement, via “direct” API (supported driver). default NULL means backend choose whatever API makes sense database, (relevant) tries API first attempt fails. successful second attempt result message suggests passing correct immediate argument. Examples possible behaviors: DBI backend defaults immediate = TRUE internally query without parameters passed: query executed query parameters passed: params given: rejected immediately database syntax error query, backend tries immediate = FALSE (gives message) params given: query executed using immediate = FALSE DBI backend defaults immediate = FALSE internally query without parameters passed: simple query: query executed “special” query (setting config options): fails, backend tries immediate = TRUE (gives message) query parameters passed: params given: waiting parameters via dbBind() params given: query executed","code":""},{"path":"/articles/spec.html","id":"details-6","dir":"Articles","previous_headings":"Change database state","what":"Details","title":"DBI specification","text":"can also use dbExecute() call stored procedure performs data manipulation actions return result set. execute stored procedure returns result set, data manipulation query also returns result set ⁠INSERT ... RETURNING ...⁠, use dbGetQuery() instead.","code":""},{"path":"/articles/spec.html","id":"value-9","dir":"Articles","previous_headings":"Change database state","what":"Value","title":"DBI specification","text":"dbExecute() always returns scalar numeric specifies number rows affected statement.","code":""},{"path":"/articles/spec.html","id":"implementation-notes-1","dir":"Articles","previous_headings":"Change database state","what":"Implementation notes","title":"DBI specification","text":"Subclasses override method provide sort performance optimization.","code":""},{"path":"/articles/spec.html","id":"failure-modes-8","dir":"Articles","previous_headings":"Change database state","what":"Failure modes","title":"DBI specification","text":"error raised issuing statement closed invalid connection, syntax statement invalid, statement non-NA string.","code":""},{"path":"/articles/spec.html","id":"examples-10","dir":"Articles","previous_headings":"Change database state","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"cars\", head(cars, 3)) dbReadTable(con, \"cars\")   # there are 3 rows dbExecute(   con,   \"INSERT INTO cars (speed, dist) VALUES (1, 1), (2, 2), (3, 3)\" ) dbReadTable(con, \"cars\")   # there are now 6 rows  # Pass values using the param argument: dbExecute(   con,   \"INSERT INTO cars (speed, dist) VALUES (?, ?)\",   params = list(4:7, 5:8) ) dbReadTable(con, \"cars\")   # there are now 10 rows  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"quote-literal-strings","dir":"Articles","previous_headings":"","what":"Quote literal strings","title":"DBI specification","text":"section describes behavior following method:","code":"dbQuoteString(conn, x, ...)"},{"path":"/articles/spec.html","id":"description-10","dir":"Articles","previous_headings":"Quote literal strings","what":"Description","title":"DBI specification","text":"Call method generate string suitable use query string literal, make sure generate valid SQL protect SQL injection attacks.","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-10","dir":"Articles","previous_headings":"Quote literal strings","what":"Value","title":"DBI specification","text":"dbQuoteString() returns object can coerced character, length input. empty character vector function returns length-0 object. passing returned object dbQuoteString() x argument, returned unchanged. Passing objects class SQL also return unchanged. (backends may convenient return SQL objects achieve behavior, required.)","code":""},{"path":"/articles/spec.html","id":"failure-modes-9","dir":"Articles","previous_headings":"Quote literal strings","what":"Failure modes","title":"DBI specification","text":"Passing numeric, integer, logical, raw vector, list x argument raises error.","code":""},{"path":"/articles/spec.html","id":"specification-9","dir":"Articles","previous_headings":"Quote literal strings","what":"Specification","title":"DBI specification","text":"returned expression can used ⁠SELECT ...⁠ query, scalar character x value dbGetQuery(paste0(\"SELECT \", dbQuoteString(x)))[[1]] must identical x, even x contains spaces, tabs, quotes (single double), backticks, newlines (combination) result dbQuoteString() call coerced back character (even repeatedly). x NA, result must merely satisfy .na(). strings \"NA\" \"NULL\" treated specially. NA translated unquoted SQL NULL, query ⁠SELECT * (SELECT 1) ... NULL⁠ returns one row.","code":""},{"path":"/articles/spec.html","id":"examples-11","dir":"Articles","previous_headings":"Quote literal strings","what":"Examples","title":"DBI specification","text":"","code":"# Quoting ensures that arbitrary input is safe for use in a query name <- \"Robert'); DROP TABLE Students;--\" dbQuoteString(ANSI(), name)  # NAs become NULL dbQuoteString(ANSI(), c(\"x\", NA))  # SQL vectors are always passed through as is var_name <- SQL(\"select\") var_name dbQuoteString(ANSI(), var_name)  # This mechanism is used to prevent double escaping dbQuoteString(ANSI(), dbQuoteString(ANSI(), name))"},{"path":"/articles/spec.html","id":"quote-identifiers","dir":"Articles","previous_headings":"","what":"Quote identifiers","title":"DBI specification","text":"section describes behavior following method:","code":"dbQuoteIdentifier(conn, x, ...)"},{"path":"/articles/spec.html","id":"description-11","dir":"Articles","previous_headings":"Quote identifiers","what":"Description","title":"DBI specification","text":"Call method generate string suitable use query column table name, make sure generate valid SQL protect SQL injection attacks. inverse operation dbUnquoteIdentifier().","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-11","dir":"Articles","previous_headings":"Quote identifiers","what":"Value","title":"DBI specification","text":"dbQuoteIdentifier() returns object can coerced character, length input. empty character vector function returns length-0 object. names input argument preserved output. passing returned object dbQuoteIdentifier() x argument, returned unchanged. Passing objects class SQL also return unchanged. (backends may convenient return SQL objects achieve behavior, required.)","code":""},{"path":"/articles/spec.html","id":"failure-modes-10","dir":"Articles","previous_headings":"Quote identifiers","what":"Failure modes","title":"DBI specification","text":"error raised input contains NA, empty string.","code":""},{"path":"/articles/spec.html","id":"specification-10","dir":"Articles","previous_headings":"Quote identifiers","what":"Specification","title":"DBI specification","text":"Calling dbGetQuery() query format ⁠SELECT 1 ...⁠ returns data frame identifier, unquoted, column name. Quoted identifiers can used table column names SQL queries, particular queries like ⁠SELECT 1 ...⁠ ⁠SELECT * (SELECT 1) ...⁠. method must use quoting mechanism unambiguously different quoting mechanism used strings, query like ⁠SELECT ... (SELECT 1 ...)⁠ throws error column names match. method can quote column names contain special characters space, dot, comma, quotes used mark strings identifiers, database supports . case, checking validity identifier performed executing query, dbQuoteIdentifier().","code":""},{"path":"/articles/spec.html","id":"examples-12","dir":"Articles","previous_headings":"Quote identifiers","what":"Examples","title":"DBI specification","text":"","code":"# Quoting ensures that arbitrary input is safe for use in a query name <- \"Robert'); DROP TABLE Students;--\" dbQuoteIdentifier(ANSI(), name)  # Use Id() to specify other components such as the schema id_name <- Id(schema = \"schema_name\", table = \"table_name\") id_name dbQuoteIdentifier(ANSI(), id_name)  # SQL vectors are always passed through as is var_name <- SQL(\"select\") var_name dbQuoteIdentifier(ANSI(), var_name)  # This mechanism is used to prevent double escaping dbQuoteIdentifier(ANSI(), dbQuoteIdentifier(ANSI(), name))"},{"path":"/articles/spec.html","id":"read-database-tables-as-data-frames","dir":"Articles","previous_headings":"","what":"Read database tables as data frames","title":"DBI specification","text":"section describes behavior following method:","code":"dbReadTable(conn, name, ...)"},{"path":"/articles/spec.html","id":"description-12","dir":"Articles","previous_headings":"Read database tables as data frames","what":"Description","title":"DBI specification","text":"Reads database table data frame, optionally converting column row names converting column names valid R identifiers. Use dbReadTableArrow() instead obtain Arrow object.","code":""},{"path":"/articles/spec.html","id":"arguments-12","dir":"Articles","previous_headings":"Read database tables as data frames","what":"Arguments","title":"DBI specification","text":"DBIConnection object, returned dbConnect(). table name, passed dbQuoteIdentifier(). Options : character string unquoted DBMS table name, e.g. “table_name”, call Id() components fully qualified table name, e.g. Id(schema = “my_schema”, table = “table_name”) call SQL() quoted fully qualified table name given verbatim, e.g. SQL(‘“my_schema”.”table_name”’) parameters passed methods.","code":""},{"path":"/articles/spec.html","id":"additional-arguments-4","dir":"Articles","previous_headings":"Read database tables as data frames","what":"Additional arguments","title":"DBI specification","text":"following arguments part dbReadTable() generic (improve compatibility across backends) part DBI specification: row.names (default: FALSE) check.names must provided named arguments. See “Value” section details usage.","code":""},{"path":"/articles/spec.html","id":"specification-11","dir":"Articles","previous_headings":"Read database tables as data frames","what":"Specification","title":"DBI specification","text":"name argument processed follows, support databases allow non-syntactic names objects: unquoted table name string: dbReadTable() quoting, perhaps calling dbQuoteIdentifier(conn, x = name) result call dbQuoteIdentifier(): quoting done","code":""},{"path":"/articles/spec.html","id":"details-7","dir":"Articles","previous_headings":"Read database tables as data frames","what":"Details","title":"DBI specification","text":"function returns data frame. Use dbReadTableArrow() obtain Arrow object.","code":""},{"path":"/articles/spec.html","id":"value-12","dir":"Articles","previous_headings":"Read database tables as data frames","what":"Value","title":"DBI specification","text":"dbReadTable() returns data frame contains complete data remote table, effectively result calling dbGetQuery() ⁠SELECT * <name>⁠. empty table returned data frame zero rows. presence rownames depends row.names argument, see sqlColumnToRownames() details: FALSE NULL, returned data frame doesn’t row names. TRUE, column named “row_names” converted row names. NA, column named “row_names” converted row names exists, otherwise translation occurs. string, specifies name column remote table contains row names. default row.names = FALSE. database supports identifiers special characters, columns returned data frame converted valid R identifiers check.names argument TRUE, check.names = FALSE, returned table non-syntactic column names without quotes.","code":""},{"path":"/articles/spec.html","id":"failure-modes-11","dir":"Articles","previous_headings":"Read database tables as data frames","what":"Failure modes","title":"DBI specification","text":"error raised table exist. error raised row.names TRUE “row_names” column exists, error raised row.names set string corresponding column exists. error raised calling method closed invalid connection. error raised name processed dbQuoteIdentifier() results non-scalar. Unsupported values row.names check.names (non-scalars, unsupported data types, NA check.names) also raise error.","code":""},{"path":"/articles/spec.html","id":"examples-13","dir":"Articles","previous_headings":"Read database tables as data frames","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"mtcars\", mtcars[1:10, ]) dbReadTable(con, \"mtcars\")  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"copy-data-frames-to-database-tables","dir":"Articles","previous_headings":"","what":"Copy data frames to database tables","title":"DBI specification","text":"section describes behavior following method:","code":"dbWriteTable(conn, name, value, ...)"},{"path":"/articles/spec.html","id":"description-13","dir":"Articles","previous_headings":"Copy data frames to database tables","what":"Description","title":"DBI specification","text":"Writes, overwrites appends data frame database table, optionally converting row names column specifying SQL data types fields.","code":""},{"path":"/articles/spec.html","id":"arguments-13","dir":"Articles","previous_headings":"Copy data frames to database tables","what":"Arguments","title":"DBI specification","text":"DBIConnection object, returned dbConnect(). table name, passed dbQuoteIdentifier(). Options : character string unquoted DBMS table name, e.g. “table_name”, call Id() components fully qualified table name, e.g. Id(schema = “my_schema”, table = “table_name”) call SQL() quoted fully qualified table name given verbatim, e.g. SQL(‘“my_schema”.”table_name”’) data.frame (coercible data.frame). parameters passed methods.","code":""},{"path":"/articles/spec.html","id":"additional-arguments-5","dir":"Articles","previous_headings":"Copy data frames to database tables","what":"Additional arguments","title":"DBI specification","text":"following arguments part dbWriteTable() generic (improve compatibility across backends) part DBI specification: row.names (default: FALSE) overwrite (default: FALSE) append (default: FALSE) field.types (default: NULL) temporary (default: FALSE) must provided named arguments. See “Specification” “Value” sections details usage.","code":""},{"path":"/articles/spec.html","id":"specification-12","dir":"Articles","previous_headings":"Copy data frames to database tables","what":"Specification","title":"DBI specification","text":"name argument processed follows, support databases allow non-syntactic names objects: unquoted table name string: dbWriteTable() quoting, perhaps calling dbQuoteIdentifier(conn, x = name) result call dbQuoteIdentifier(): quoting done value argument must data frame subset columns existing table append = TRUE. order columns matter append = TRUE. overwrite argument TRUE, existing table name overwritten. argument doesn’t change behavior table exist yet. append argument TRUE, rows existing table preserved, new data appended. table doesn’t exist yet, created. temporary argument TRUE, table available second connection gone reconnecting. backends support argument. regular, non-temporary table visible second connection, pre-existing connection, reconnecting database. SQL keywords can used freely table names, column names, data. Quotes, commas, spaces, special characters newlines tabs, can also used data, , database supports non-syntactic identifiers, also table names column names. following data types must supported least, read identically dbReadTable(): integer numeric (behavior Inf NaN specified) logical NA NULL 64-bit values (using \"bigint\" field type); result can converted numeric, may lose precision, converted character vector, gives full decimal representation written another table read unchanged character (UTF-8 native encodings), supporting empty strings non-empty string factor (returned character) list raw (supported database) objects type blob::blob (supported database) date (supported database; returned Date), also dates prior 1970 1900 2038 time (supported database; returned objects inherit difftime) timestamp (supported database; returned POSIXct respecting time zone necessarily preserving input time zone), also timestamps prior 1970 1900 2038 respecting time zone necessarily preserving input time zone) Mixing column types table supported. field.types argument must named character vector one entry column. indicates SQL data type used new column. column missed field.types, type inferred input data dbDataType(). interpretation rownames depends row.names argument, see sqlRownamesToColumn() details: FALSE NULL, row names ignored. TRUE, row names converted column named “row_names”, even input data frame natural row names 1 nrow(...). NA, column named “row_names” created data custom row names, extra column created case natural row names. string, specifies name column remote table contains row names, even input data frame natural row names. default row.names = FALSE.","code":""},{"path":"/articles/spec.html","id":"details-8","dir":"Articles","previous_headings":"Copy data frames to database tables","what":"Details","title":"DBI specification","text":"function expects data frame. Use dbWriteTableArrow() write Arrow object. function useful want create load table time. Use dbAppendTable() dbAppendTableArrow() appending data existing table, dbCreateTable() dbCreateTableArrow() creating table, dbExistsTable() dbRemoveTable() overwriting tables. DBI standardizes writing data frames dbWriteTable(). backends might implement methods can consume CSV files data formats. details, see documentation individual methods.","code":""},{"path":"/articles/spec.html","id":"value-13","dir":"Articles","previous_headings":"Copy data frames to database tables","what":"Value","title":"DBI specification","text":"dbWriteTable() returns TRUE, invisibly.","code":""},{"path":"/articles/spec.html","id":"failure-modes-12","dir":"Articles","previous_headings":"Copy data frames to database tables","what":"Failure modes","title":"DBI specification","text":"table exists, append overwrite arguments unset, append = TRUE data frame new data different column names, error raised; remote table remains unchanged. error raised calling method closed invalid connection. error also raised name processed dbQuoteIdentifier() results non-scalar. Invalid values additional arguments row.names, overwrite, append, field.types, temporary (non-scalars, unsupported data types, NA, incompatible values, duplicate missing names, incompatible columns) also raise error.","code":""},{"path":"/articles/spec.html","id":"examples-14","dir":"Articles","previous_headings":"Copy data frames to database tables","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"mtcars\", mtcars[1:5, ]) dbReadTable(con, \"mtcars\")  dbWriteTable(con, \"mtcars\", mtcars[6:10, ], append = TRUE) dbReadTable(con, \"mtcars\")  dbWriteTable(con, \"mtcars\", mtcars[1:10, ], overwrite = TRUE) dbReadTable(con, \"mtcars\")  # No row names dbWriteTable(con, \"mtcars\", mtcars[1:10, ], overwrite = TRUE, row.names = FALSE) dbReadTable(con, \"mtcars\")"},{"path":"/articles/spec.html","id":"list-remote-tables","dir":"Articles","previous_headings":"","what":"List remote tables","title":"DBI specification","text":"section describes behavior following method:","code":"dbListTables(conn, ...)"},{"path":"/articles/spec.html","id":"description-14","dir":"Articles","previous_headings":"List remote tables","what":"Description","title":"DBI specification","text":"Returns unquoted names remote tables accessible connection. include views temporary objects, database backends (particular RMariaDB RMySQL) support .","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-14","dir":"Articles","previous_headings":"List remote tables","what":"Value","title":"DBI specification","text":"dbListTables() returns character vector enumerates tables views database. Tables added dbWriteTable() part list. soon table removed database, also removed list database tables. applies temporary tables supported database. returned names suitable quoting dbQuoteIdentifier().","code":""},{"path":"/articles/spec.html","id":"failure-modes-13","dir":"Articles","previous_headings":"List remote tables","what":"Failure modes","title":"DBI specification","text":"error raised calling method closed invalid connection.","code":""},{"path":"/articles/spec.html","id":"examples-15","dir":"Articles","previous_headings":"List remote tables","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbListTables(con) dbWriteTable(con, \"mtcars\", mtcars) dbListTables(con)  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"does-a-table-exist","dir":"Articles","previous_headings":"","what":"Does a table exist?","title":"DBI specification","text":"section describes behavior following method:","code":"dbExistsTable(conn, name, ...)"},{"path":"/articles/spec.html","id":"description-15","dir":"Articles","previous_headings":"Does a table exist?","what":"Description","title":"DBI specification","text":"Returns table given name exists database.","code":""},{"path":"/articles/spec.html","id":"arguments-15","dir":"Articles","previous_headings":"Does a table exist?","what":"Arguments","title":"DBI specification","text":"DBIConnection object, returned dbConnect(). table name, passed dbQuoteIdentifier(). Options : character string unquoted DBMS table name, e.g. “table_name”, call Id() components fully qualified table name, e.g. Id(schema = “my_schema”, table = “table_name”) call SQL() quoted fully qualified table name given verbatim, e.g. SQL(‘“my_schema”.”table_name”’) parameters passed methods.","code":""},{"path":"/articles/spec.html","id":"value-15","dir":"Articles","previous_headings":"Does a table exist?","what":"Value","title":"DBI specification","text":"dbExistsTable() returns logical scalar, TRUE table view specified name argument exists, FALSE otherwise. includes temporary tables supported database.","code":""},{"path":"/articles/spec.html","id":"failure-modes-14","dir":"Articles","previous_headings":"Does a table exist?","what":"Failure modes","title":"DBI specification","text":"error raised calling method closed invalid connection. error also raised name processed dbQuoteIdentifier() results non-scalar.","code":""},{"path":"/articles/spec.html","id":"specification-13","dir":"Articles","previous_headings":"Does a table exist?","what":"Specification","title":"DBI specification","text":"name argument processed follows, support databases allow non-syntactic names objects: unquoted table name string: dbExistsTable() quoting, perhaps calling dbQuoteIdentifier(conn, x = name) result call dbQuoteIdentifier(): quoting done tables listed dbListTables(), dbExistsTable() returns TRUE.","code":""},{"path":"/articles/spec.html","id":"examples-16","dir":"Articles","previous_headings":"Does a table exist?","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbExistsTable(con, \"iris\") dbWriteTable(con, \"iris\", iris) dbExistsTable(con, \"iris\")  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"remove-a-table-from-the-database","dir":"Articles","previous_headings":"","what":"Remove a table from the database","title":"DBI specification","text":"section describes behavior following method:","code":"dbRemoveTable(conn, name, ...)"},{"path":"/articles/spec.html","id":"description-16","dir":"Articles","previous_headings":"Remove a table from the database","what":"Description","title":"DBI specification","text":"Remove remote table (e.g., created dbWriteTable()) database.","code":""},{"path":"/articles/spec.html","id":"arguments-16","dir":"Articles","previous_headings":"Remove a table from the database","what":"Arguments","title":"DBI specification","text":"DBIConnection object, returned dbConnect(). table name, passed dbQuoteIdentifier(). Options : character string unquoted DBMS table name, e.g. “table_name”, call Id() components fully qualified table name, e.g. Id(schema = “my_schema”, table = “table_name”) call SQL() quoted fully qualified table name given verbatim, e.g. SQL(‘“my_schema”.”table_name”’) parameters passed methods.","code":""},{"path":"/articles/spec.html","id":"additional-arguments-6","dir":"Articles","previous_headings":"Remove a table from the database","what":"Additional arguments","title":"DBI specification","text":"following arguments part dbRemoveTable() generic (improve compatibility across backends) part DBI specification: temporary (default: FALSE) fail_if_missing (default: TRUE) arguments must provided named arguments. temporary TRUE, call dbRemoveTable() consider temporary tables. backends support argument. particular, permanent tables name left untouched. fail_if_missing FALSE, call dbRemoveTable() succeeds table exist.","code":""},{"path":"/articles/spec.html","id":"specification-14","dir":"Articles","previous_headings":"Remove a table from the database","what":"Specification","title":"DBI specification","text":"table removed dbRemoveTable() doesn’t appear list tables returned dbListTables(), dbExistsTable() returns FALSE. removal propagates immediately connections database. function can also used remove temporary table. name argument processed follows, support databases allow non-syntactic names objects: unquoted table name string: dbRemoveTable() quoting, perhaps calling dbQuoteIdentifier(conn, x = name) result call dbQuoteIdentifier(): quoting done","code":""},{"path":"/articles/spec.html","id":"value-16","dir":"Articles","previous_headings":"Remove a table from the database","what":"Value","title":"DBI specification","text":"dbRemoveTable() returns TRUE, invisibly.","code":""},{"path":"/articles/spec.html","id":"failure-modes-15","dir":"Articles","previous_headings":"Remove a table from the database","what":"Failure modes","title":"DBI specification","text":"table exist, error raised. attempt remove view function may result error. error raised calling method closed invalid connection. error also raised name processed dbQuoteIdentifier() results non-scalar.","code":""},{"path":"/articles/spec.html","id":"examples-17","dir":"Articles","previous_headings":"Remove a table from the database","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbExistsTable(con, \"iris\") dbWriteTable(con, \"iris\", iris) dbExistsTable(con, \"iris\") dbRemoveTable(con, \"iris\") dbExistsTable(con, \"iris\")  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"list-field-names-of-a-remote-table","dir":"Articles","previous_headings":"","what":"List field names of a remote table","title":"DBI specification","text":"section describes behavior following method:","code":"dbListFields(conn, name, ...)"},{"path":"/articles/spec.html","id":"description-17","dir":"Articles","previous_headings":"List field names of a remote table","what":"Description","title":"DBI specification","text":"Returns field names remote table character vector.","code":""},{"path":"/articles/spec.html","id":"arguments-17","dir":"Articles","previous_headings":"List field names of a remote table","what":"Arguments","title":"DBI specification","text":"DBIConnection object, returned dbConnect(). table name, passed dbQuoteIdentifier(). Options : character string unquoted DBMS table name, e.g. “table_name”, call Id() components fully qualified table name, e.g. Id(schema = “my_schema”, table = “table_name”) call SQL() quoted fully qualified table name given verbatim, e.g. SQL(‘“my_schema”.”table_name”’) parameters passed methods.","code":""},{"path":"/articles/spec.html","id":"value-17","dir":"Articles","previous_headings":"List field names of a remote table","what":"Value","title":"DBI specification","text":"dbListFields() returns character vector enumerates fields table correct order. also works temporary tables supported database. returned names suitable quoting dbQuoteIdentifier().","code":""},{"path":"/articles/spec.html","id":"failure-modes-16","dir":"Articles","previous_headings":"List field names of a remote table","what":"Failure modes","title":"DBI specification","text":"table exist, error raised. Invalid types name argument (e.g., character length equal one, numeric) lead error. error also raised calling method closed invalid connection.","code":""},{"path":"/articles/spec.html","id":"specification-15","dir":"Articles","previous_headings":"List field names of a remote table","what":"Specification","title":"DBI specification","text":"name argument can string return value dbQuoteIdentifier() value table column return value dbListObjects() is_prefix FALSE column named row_names treated like column.","code":""},{"path":"/articles/spec.html","id":"examples-18","dir":"Articles","previous_headings":"List field names of a remote table","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"mtcars\", mtcars) dbListFields(con, \"mtcars\")  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"is-this-dbms-object-still-valid","dir":"Articles","previous_headings":"","what":"Is this DBMS object still valid?","title":"DBI specification","text":"section describes behavior following method:","code":"dbIsValid(dbObj, ...)"},{"path":"/articles/spec.html","id":"description-18","dir":"Articles","previous_headings":"Is this DBMS object still valid?","what":"Description","title":"DBI specification","text":"generic tests whether database object still valid (.e. hasn’t disconnected cleared).","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-18","dir":"Articles","previous_headings":"Is this DBMS object still valid?","what":"Value","title":"DBI specification","text":"dbIsValid() returns logical scalar, TRUE object specified dbObj valid, FALSE otherwise. DBIConnection object initially valid, becomes invalid disconnecting dbDisconnect(). invalid connection object (e.g., drivers object saved file restored), method also returns FALSE. DBIResult object valid call dbSendQuery(), stays valid even rows fetched; clearing dbClearResult() invalidates . DBIResult object also valid call dbSendStatement(), stays valid querying number rows affected; clearing dbClearResult() invalidates . connection database system dropped (e.g., due connectivity problems, server failure, etc.), dbIsValid() return FALSE. tested automatically.","code":""},{"path":"/articles/spec.html","id":"examples-19","dir":"Articles","previous_headings":"Is this DBMS object still valid?","what":"Examples","title":"DBI specification","text":"","code":"dbIsValid(RSQLite::SQLite())  con <- dbConnect(RSQLite::SQLite(), \":memory:\") dbIsValid(con)  rs <- dbSendQuery(con, \"SELECT 1\") dbIsValid(rs)  dbClearResult(rs) dbIsValid(rs)  dbDisconnect(con) dbIsValid(con)"},{"path":"/articles/spec.html","id":"completion-status","dir":"Articles","previous_headings":"","what":"Completion status","title":"DBI specification","text":"section describes behavior following method:","code":"dbHasCompleted(res, ...)"},{"path":"/articles/spec.html","id":"description-19","dir":"Articles","previous_headings":"Completion status","what":"Description","title":"DBI specification","text":"method returns operation completed. SELECT query completed rows fetched. data manipulation statement always completed.","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-19","dir":"Articles","previous_headings":"Completion status","what":"Value","title":"DBI specification","text":"dbHasCompleted() returns logical scalar. query initiated dbSendQuery() non-empty result set, dbHasCompleted() returns FALSE initially TRUE calling dbFetch() without limit. query initiated dbSendStatement(), dbHasCompleted() always returns TRUE.","code":""},{"path":"/articles/spec.html","id":"the-data-retrieval-flow-4","dir":"Articles","previous_headings":"Completion status","what":"The data retrieval flow","title":"DBI specification","text":"section gives complete overview flow execution queries return tabular data data frames. flow, except repeated calling dbBind() dbBindArrow(), implemented dbGetQuery(), sufficient unless want access results paged way parameterized query want reuse. flow requires active connection established dbConnect(). See also vignette(\"dbi-advanced\") walkthrough. Use dbSendQuery() create result set object class DBIResult. Optionally, bind query parameters dbBind() dbBindArrow(). required query contains placeholders ⁠?⁠ ⁠\\$1⁠, depending database backend. Optionally, use dbColumnInfo() retrieve structure result set without retrieving actual data. Use dbFetch() get entire result set, page results, remaining rows. Fetching zero rows also possible retrieve structure result set data frame. step can called multiple times. forward paging supported, need cache previous pages need navigate backwards. Use dbHasCompleted() tell ’re done. method returns TRUE rows available fetching. Repeat last four steps necessary. Use dbClearResult() clean result set object. step mandatory even rows fetched error occurred processing. good practice use .exit() withr::defer() ensure step always executed.","code":""},{"path":"/articles/spec.html","id":"failure-modes-17","dir":"Articles","previous_headings":"Completion status","what":"Failure modes","title":"DBI specification","text":"Attempting query completion status result set cleared dbClearResult() gives error.","code":""},{"path":"/articles/spec.html","id":"specification-16","dir":"Articles","previous_headings":"Completion status","what":"Specification","title":"DBI specification","text":"completion status query guaranteed set FALSE attempting fetch past end entire result. Therefore, query empty result set, initial return value unspecified, result value TRUE trying fetch one row. Similarly, query result set length n, return value unspecified fetching n rows, result value TRUE trying fetch one row.","code":""},{"path":"/articles/spec.html","id":"examples-20","dir":"Articles","previous_headings":"Completion status","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"mtcars\", mtcars) rs <- dbSendQuery(con, \"SELECT * FROM mtcars\")  dbHasCompleted(rs) ret1 <- dbFetch(rs, 10) dbHasCompleted(rs) ret2 <- dbFetch(rs) dbHasCompleted(rs)  dbClearResult(rs) dbDisconnect(con)"},{"path":"/articles/spec.html","id":"get-the-statement-associated-with-a-result-set","dir":"Articles","previous_headings":"","what":"Get the statement associated with a result set","title":"DBI specification","text":"section describes behavior following method:","code":"dbGetStatement(res, ...)"},{"path":"/articles/spec.html","id":"description-20","dir":"Articles","previous_headings":"Get the statement associated with a result set","what":"Description","title":"DBI specification","text":"Returns statement passed dbSendQuery() dbSendStatement().","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-20","dir":"Articles","previous_headings":"Get the statement associated with a result set","what":"Value","title":"DBI specification","text":"dbGetStatement() returns string, query used either dbSendQuery() dbSendStatement().","code":""},{"path":"/articles/spec.html","id":"failure-modes-18","dir":"Articles","previous_headings":"Get the statement associated with a result set","what":"Failure modes","title":"DBI specification","text":"Attempting query statement result set cleared dbClearResult() gives error.","code":""},{"path":"/articles/spec.html","id":"examples-21","dir":"Articles","previous_headings":"Get the statement associated with a result set","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"mtcars\", mtcars) rs <- dbSendQuery(con, \"SELECT * FROM mtcars\") dbGetStatement(rs)  dbClearResult(rs) dbDisconnect(con)"},{"path":"/articles/spec.html","id":"the-number-of-rows-fetched-so-far","dir":"Articles","previous_headings":"","what":"The number of rows fetched so far","title":"DBI specification","text":"section describes behavior following method:","code":"dbGetRowCount(res, ...)"},{"path":"/articles/spec.html","id":"description-21","dir":"Articles","previous_headings":"The number of rows fetched so far","what":"Description","title":"DBI specification","text":"Returns total number rows actually fetched calls dbFetch() result set.","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-21","dir":"Articles","previous_headings":"The number of rows fetched so far","what":"Value","title":"DBI specification","text":"dbGetRowCount() returns scalar number (integer numeric), number rows fetched far. calling dbSendQuery(), row count initially zero. call dbFetch() without limit, row count matches total number rows returned. Fetching limited number rows increases number rows number rows returned, even fetching past end result set. queries empty result set, zero returned even fetching. data manipulation statements issued dbSendStatement(), zero returned calling dbFetch().","code":""},{"path":"/articles/spec.html","id":"failure-modes-19","dir":"Articles","previous_headings":"The number of rows fetched so far","what":"Failure modes","title":"DBI specification","text":"Attempting get row count result set cleared dbClearResult() gives error.","code":""},{"path":"/articles/spec.html","id":"examples-22","dir":"Articles","previous_headings":"The number of rows fetched so far","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"mtcars\", mtcars) rs <- dbSendQuery(con, \"SELECT * FROM mtcars\")  dbGetRowCount(rs) ret1 <- dbFetch(rs, 10) dbGetRowCount(rs) ret2 <- dbFetch(rs) dbGetRowCount(rs) nrow(ret1) + nrow(ret2)  dbClearResult(rs) dbDisconnect(con)"},{"path":"/articles/spec.html","id":"the-number-of-rows-affected","dir":"Articles","previous_headings":"","what":"The number of rows affected","title":"DBI specification","text":"section describes behavior following method:","code":"dbGetRowsAffected(res, ...)"},{"path":"/articles/spec.html","id":"description-22","dir":"Articles","previous_headings":"The number of rows affected","what":"Description","title":"DBI specification","text":"method returns number rows added, deleted, updated data manipulation statement.","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-22","dir":"Articles","previous_headings":"The number of rows affected","what":"Value","title":"DBI specification","text":"dbGetRowsAffected() returns scalar number (integer numeric), number rows affected data manipulation statement issued dbSendStatement(). value available directly call change calling dbFetch(). NA_integer_ NA_numeric_ allowed number rows affected known. queries issued dbSendQuery(), zero returned call dbFetch(). NA values allowed.","code":""},{"path":"/articles/spec.html","id":"the-command-execution-flow-3","dir":"Articles","previous_headings":"The number of rows affected","what":"The command execution flow","title":"DBI specification","text":"section gives complete overview flow execution SQL statements side effects stored procedures, inserting deleting data, setting database connection options. flow, except repeated calling dbBindArrow(), implemented dbExecute(), sufficient non-parameterized queries. flow requires active connection established dbConnect(). See also vignette(\"dbi-advanced\") walkthrough. Use dbSendStatement() create result set object class DBIResult. queries need pass immediate = TRUE. Optionally, bind query parameters withdbBind() dbBindArrow(). required query contains placeholders ⁠?⁠ ⁠\\$1⁠, depending database backend. Optionally, use dbGetRowsAffected() retrieve number rows affected query. Repeat last two steps necessary. Use dbClearResult() clean result set object. step mandatory even rows fetched error occurred processing. good practice use .exit() withr::defer() ensure step always executed.","code":""},{"path":"/articles/spec.html","id":"failure-modes-20","dir":"Articles","previous_headings":"The number of rows affected","what":"Failure modes","title":"DBI specification","text":"Attempting get rows affected result set cleared dbClearResult() gives error.","code":""},{"path":"/articles/spec.html","id":"examples-23","dir":"Articles","previous_headings":"The number of rows affected","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"mtcars\", mtcars) rs <- dbSendStatement(con, \"DELETE FROM mtcars\") dbGetRowsAffected(rs) nrow(mtcars)  dbClearResult(rs) dbDisconnect(con)"},{"path":"/articles/spec.html","id":"information-about-result-types","dir":"Articles","previous_headings":"","what":"Information about result types","title":"DBI specification","text":"section describes behavior following method:","code":"dbColumnInfo(res, ...)"},{"path":"/articles/spec.html","id":"description-23","dir":"Articles","previous_headings":"Information about result types","what":"Description","title":"DBI specification","text":"Produces data.frame describes output query. data.frame many rows output fields result set, column data.frame describes aspect result set field (field name, type, etc.)","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-23","dir":"Articles","previous_headings":"Information about result types","what":"Value","title":"DBI specification","text":"dbColumnInfo() returns data frame least two columns \"name\" \"type\" (order) (optional columns start dot). \"name\" \"type\" columns contain names types R columns data frame returned dbFetch(). \"type\" column type character information. compute \"type\" column, instead use dbFetch(res, n = 0) create zero-row data frame initialized correct data types.","code":""},{"path":"/articles/spec.html","id":"the-data-retrieval-flow-5","dir":"Articles","previous_headings":"Information about result types","what":"The data retrieval flow","title":"DBI specification","text":"section gives complete overview flow execution queries return tabular data data frames. flow, except repeated calling dbBind() dbBindArrow(), implemented dbGetQuery(), sufficient unless want access results paged way parameterized query want reuse. flow requires active connection established dbConnect(). See also vignette(\"dbi-advanced\") walkthrough. Use dbSendQuery() create result set object class DBIResult. Optionally, bind query parameters dbBind() dbBindArrow(). required query contains placeholders ⁠?⁠ ⁠\\$1⁠, depending database backend. Optionally, use dbColumnInfo() retrieve structure result set without retrieving actual data. Use dbFetch() get entire result set, page results, remaining rows. Fetching zero rows also possible retrieve structure result set data frame. step can called multiple times. forward paging supported, need cache previous pages need navigate backwards. Use dbHasCompleted() tell ’re done. method returns TRUE rows available fetching. Repeat last four steps necessary. Use dbClearResult() clean result set object. step mandatory even rows fetched error occurred processing. good practice use .exit() withr::defer() ensure step always executed.","code":""},{"path":"/articles/spec.html","id":"failure-modes-21","dir":"Articles","previous_headings":"Information about result types","what":"Failure modes","title":"DBI specification","text":"attempt query columns closed result set raises error.","code":""},{"path":"/articles/spec.html","id":"specification-17","dir":"Articles","previous_headings":"Information about result types","what":"Specification","title":"DBI specification","text":"column named row_names treated like column. column names always consistent data returned dbFetch(). query returns unnamed columns, non-empty non-NA names assigned. Column names correspond SQL R keywords left unchanged.","code":""},{"path":"/articles/spec.html","id":"examples-24","dir":"Articles","previous_headings":"Information about result types","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  rs <- dbSendQuery(con, \"SELECT 1 AS a, 2 AS b\") dbColumnInfo(rs) dbFetch(rs)  dbClearResult(rs) dbDisconnect(con)"},{"path":"/articles/spec.html","id":"begincommitrollback-sql-transactions","dir":"Articles","previous_headings":"","what":"Begin/commit/rollback SQL transactions","title":"DBI specification","text":"section describes behavior following methods:","code":"dbBegin(conn, ...)  dbCommit(conn, ...)  dbRollback(conn, ...)"},{"path":"/articles/spec.html","id":"description-24","dir":"Articles","previous_headings":"Begin/commit/rollback SQL transactions","what":"Description","title":"DBI specification","text":"transaction encapsulates several SQL statements atomic unit. initiated dbBegin() either made persistent dbCommit() undone dbRollback(). case, DBMS guarantees either none statements permanent effect. helps ensuring consistency write operations multiple tables.","code":""},{"path":[]},{"path":"/articles/spec.html","id":"details-9","dir":"Articles","previous_headings":"Begin/commit/rollback SQL transactions","what":"Details","title":"DBI specification","text":"database engines implement transaction management, case methods implemented specific DBIConnection subclass.","code":""},{"path":"/articles/spec.html","id":"value-24","dir":"Articles","previous_headings":"Begin/commit/rollback SQL transactions","what":"Value","title":"DBI specification","text":"dbBegin(), dbCommit() dbRollback() return TRUE, invisibly.","code":""},{"path":"/articles/spec.html","id":"failure-modes-22","dir":"Articles","previous_headings":"Begin/commit/rollback SQL transactions","what":"Failure modes","title":"DBI specification","text":"implementations expected raise error case failure, tested. way, generics throw error closed invalid connection. addition, call dbCommit() dbRollback() without prior call dbBegin() raises error. Nested transactions supported DBI, attempt call dbBegin() twice yields error.","code":""},{"path":"/articles/spec.html","id":"specification-18","dir":"Articles","previous_headings":"Begin/commit/rollback SQL transactions","what":"Specification","title":"DBI specification","text":"Actual support transactions may vary backends. transaction initiated call dbBegin() committed call dbCommit(). Data written transaction must persist transaction committed. example, record missing transaction started created transaction must exist transaction, also new connection. transaction can also aborted dbRollback(). data written transaction must removed transaction rolled back. example, record missing transaction started created transaction must exist anymore rollback. Disconnection connection open transaction effectively rolls back transaction. data written transaction must removed transaction rolled back. behavior specified arguments passed functions. particular, RSQLite issues named transactions support nesting name argument set. transaction isolation level specified DBI.","code":""},{"path":"/articles/spec.html","id":"examples-25","dir":"Articles","previous_headings":"Begin/commit/rollback SQL transactions","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"cash\", data.frame(amount = 100)) dbWriteTable(con, \"account\", data.frame(amount = 2000))  # All operations are carried out as logical unit: dbBegin(con) withdrawal <- 300 dbExecute(con, \"UPDATE cash SET amount = amount + ?\", list(withdrawal)) dbExecute(con, \"UPDATE account SET amount = amount - ?\", list(withdrawal)) dbCommit(con)  dbReadTable(con, \"cash\") dbReadTable(con, \"account\")  # Rolling back after detecting negative value on account: dbBegin(con) withdrawal <- 5000 dbExecute(con, \"UPDATE cash SET amount = amount + ?\", list(withdrawal)) dbExecute(con, \"UPDATE account SET amount = amount - ?\", list(withdrawal)) if (dbReadTable(con, \"account\")\\$amount >= 0) {   dbCommit(con) } else {   dbRollback(con) }  dbReadTable(con, \"cash\") dbReadTable(con, \"account\")  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"self-contained-sql-transactions","dir":"Articles","previous_headings":"","what":"Self-contained SQL transactions","title":"DBI specification","text":"section describes behavior following methods:","code":"dbWithTransaction(conn, code, ...)  dbBreak()"},{"path":"/articles/spec.html","id":"description-25","dir":"Articles","previous_headings":"Self-contained SQL transactions","what":"Description","title":"DBI specification","text":"Given transactions implemented, function allows pass code run transaction. default method dbWithTransaction() calls dbBegin() executing code, dbCommit() successful completion, dbRollback() case error. advantage don’t remember dbBegin() dbCommit() dbRollback() – taken care . special function dbBreak() allows early exit rollback, can called inside dbWithTransaction().","code":""},{"path":[]},{"path":"/articles/spec.html","id":"details-10","dir":"Articles","previous_headings":"Self-contained SQL transactions","what":"Details","title":"DBI specification","text":"DBI implements dbWithTransaction(), backends need override generic implement specialized handling.","code":""},{"path":"/articles/spec.html","id":"value-25","dir":"Articles","previous_headings":"Self-contained SQL transactions","what":"Value","title":"DBI specification","text":"dbWithTransaction() returns value executed code.","code":""},{"path":"/articles/spec.html","id":"failure-modes-23","dir":"Articles","previous_headings":"Self-contained SQL transactions","what":"Failure modes","title":"DBI specification","text":"Failure initiate transaction (e.g., connection closed invalid dbBegin() called already) gives error.","code":""},{"path":"/articles/spec.html","id":"specification-19","dir":"Articles","previous_headings":"Self-contained SQL transactions","what":"Specification","title":"DBI specification","text":"dbWithTransaction() initiates transaction dbBegin(), executes code given code argument, commits transaction dbCommit(). code raises error, transaction instead aborted dbRollback(), error propagated. code calls dbBreak(), execution code stops transaction silently aborted. side effects caused code (creation new variables) propagate calling environment.","code":""},{"path":"/articles/spec.html","id":"examples-26","dir":"Articles","previous_headings":"Self-contained SQL transactions","what":"Examples","title":"DBI specification","text":"","code":"con <- dbConnect(RSQLite::SQLite(), \":memory:\")  dbWriteTable(con, \"cash\", data.frame(amount = 100)) dbWriteTable(con, \"account\", data.frame(amount = 2000))  # All operations are carried out as logical unit: dbWithTransaction(   con,   {     withdrawal <- 300     dbExecute(con, \"UPDATE cash SET amount = amount + ?\", list(withdrawal))     dbExecute(con, \"UPDATE account SET amount = amount - ?\", list(withdrawal))   } )  # The code is executed as if in the curent environment: withdrawal  # The changes are committed to the database after successful execution: dbReadTable(con, \"cash\") dbReadTable(con, \"account\")  # Rolling back with dbBreak(): dbWithTransaction(   con,   {     withdrawal <- 5000     dbExecute(con, \"UPDATE cash SET amount = amount + ?\", list(withdrawal))     dbExecute(con, \"UPDATE account SET amount = amount - ?\", list(withdrawal))     if (dbReadTable(con, \"account\")\\$amount < 0) {       dbBreak()     }   } )  # These changes were not committed to the database: dbReadTable(con, \"cash\") dbReadTable(con, \"account\")  dbDisconnect(con)"},{"path":"/articles/spec.html","id":"get-dbms-metadata","dir":"Articles","previous_headings":"","what":"Get DBMS metadata","title":"DBI specification","text":"section describes behavior following method:","code":"dbGetInfo(dbObj, ...)"},{"path":"/articles/spec.html","id":"description-26","dir":"Articles","previous_headings":"Get DBMS metadata","what":"Description","title":"DBI specification","text":"Retrieves information objects class DBIDriver, DBIConnection DBIResult.","code":""},{"path":[]},{"path":"/articles/spec.html","id":"value-26","dir":"Articles","previous_headings":"Get DBMS metadata","what":"Value","title":"DBI specification","text":"objects class DBIDriver, dbGetInfo() returns named list contains least following components: driver.version: package version DBI backend, client.version: version DBMS client library. objects class DBIConnection, dbGetInfo() returns named list contains least following components: db.version: version database server, dbname: database name, username: username connect database, host: hostname database server, port: port database server. must contain password component. Components applicable set NA. objects class DBIResult, dbGetInfo() returns named list contains least following components: statatment: statement used dbSendQuery() dbExecute(), returned dbGetStatement(), row.count: number rows fetched far (queries), returned dbGetRowCount(), rows.affected: number rows affected (statements), returned dbGetRowsAffected() .completed: logical indicates query statement completed, returned dbHasCompleted().","code":""},{"path":"/articles/spec.html","id":"implementation-notes-2","dir":"Articles","previous_headings":"Get DBMS metadata","what":"Implementation notes","title":"DBI specification","text":"default implementation ⁠DBIResult objects⁠ constructs list return values corresponding methods, dbGetStatement(), dbGetRowCount(), dbGetRowsAffected(), dbHasCompleted().","code":""},{"path":"/articles/spec.html","id":"examples-27","dir":"Articles","previous_headings":"Get DBMS metadata","what":"Examples","title":"DBI specification","text":"","code":"dbGetInfo(RSQLite::SQLite())"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Maëlle Salmon. Maintainer, author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Salmon M (2024). notdbi: Package (One Line, Title Case). R package version 0.0.0.9000, https://github.com/maelle/notdbi.","code":"@Manual{,   title = {notdbi: What the Package Does (One Line, Title Case)},   author = {Maëlle Salmon},   year = {2024},   note = {R package version 0.0.0.9000},   url = {https://github.com/maelle/notdbi}, }"}]
